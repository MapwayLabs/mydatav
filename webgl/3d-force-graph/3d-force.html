<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>3d-force-graph</title>
    <script src="../../lib/threejs/three.js"></script>
    <script src="../../lib/d3/d3.js"></script>
    <script src="./3d-force-graph-1.45.6/dist/3d-force-graph.js"></script>
    <script src="./SelectHandler.js"></script>
    <script src="./customOrbitControl.js"></script>
    <style>
      body {
        margin: 0;
      }
    </style>
  </head>

  <body>
    <div id="3d-graph"></div>

    <script>
      // Random tree
      const N = 10;
      const gData = {
        nodes: [...Array(N).keys()].map(i => ({
          id: i
        })),
        links: [...Array(N).keys()]
          .filter(id => id)
          .map(id => ({
            source: id,
            target: Math.round(Math.random() * (id - 1))
          }))
      };

      const Graph = ForceGraph3D({
        controlType: "orbit"
      })(document.getElementById("3d-graph"))
        .graphData(gData)
        .forceEngine("d3")
        //  .forceEngine('ngraph')
        .enableNodeDrag(true)
        //  .cooldownTicks(0)
        .cooldownTime(500)
        .numDimensions(3)
        .nodeRelSize(10)
        .linkColor(0xff0000)
        .linkWidth(1)
        .linkOpacity(0.4)
        // .linkMaterial(function() {
        //     return new THREE.LineBasicMaterial({
        //         color: 0xFF0000,
        //         linewidth: 1
        //     });
        // })
        .linkThreeObject(function(link) {
          const geometry = new THREE.BufferGeometry();
          const material = new THREE.LineBasicMaterial({
            color: 0x1f3d7a,
            linewidth: 1,
            linecap: "round"
          });
          material.transparent = true;
          material.opacity = 0.5;
          const positions = [];
          positions.push(link.source.x, link.source.y, link.source.z);
          positions.push(link.target.x, link.target.y, link.target.z);
          geometry.addAttribute(
            "position",
            new THREE.Float32BufferAttribute(positions, 3)
          );
          return new THREE.Line(geometry, material);
        })
        .nodeOpacity(1)
        .d3Force("collision", d3.forceCollide(20));
      //  .linkDirectionalArrowLength(15)
      //  .linkDirectionalArrowRelPos(1)
      //  .linkCurvature(1)
      var scene = Graph.scene();
      var orbitControl = Graph.controls();
      var camera = Graph.camera();
      var renderer = Graph.renderer();
      var canvas = renderer.domElement;
      var theta = 0;
      var radius = 100;

      var customCtr = new CustomOrbitControl(scene, camera, renderer);


      var minDistance = 0;
      var maxDistance = Infinity;
      var minZoom = 0;
      var maxZoom = Infinity;
      var minPolarAngle = 0; // radians
      var maxPolarAngle = Math.PI; // radians
      var minAzimuthAngle = -Infinity; // radians
      var maxAzimuthAngle = Infinity; // radians
      var spherical = new THREE.Spherical();
      var sphericalDelta = new THREE.Spherical();
      var rotateStart = new THREE.Vector2();
      var rotateEnd = new THREE.Vector2();
      var rotateDelta = new THREE.Vector2();
      var rotateSpeed = 1.0;
      var target = new THREE.Vector3();
      var scale = 1;
      var enableDamping = true;
      var dampingFactor = 0.25;

      function rotateLeft(angle) {
        sphericalDelta.theta -= angle;
      }

      function rotateUp(angle) {
        sphericalDelta.phi -= angle;
      }
      console.log( Graph.graphData().nodes );

      function update() {
        var offset = new THREE.Vector3();
        var object = camera;
        // so camera.up is the orbit axis
        var quat = new THREE.Quaternion().setFromUnitVectors(
          object.up,
          new THREE.Vector3(0, 1, 0)
        );
        var quatInverse = quat.clone().inverse();

        var lastPosition = new THREE.Vector3();
        var lastQuaternion = new THREE.Quaternion();

        return function update() {
          // console.log('update');

          var position = object.position;

          offset.copy(position).sub(target);

          // rotate offset to "y-axis-is-up" space
          offset.applyQuaternion(quat);

          // angle from z-axis around y-axis
          spherical.setFromVector3(offset);

          // if ( scope.autoRotate && state === STATE.NONE ) {

          //     rotateLeft( getAutoRotationAngle() );

          // }

          spherical.theta += sphericalDelta.theta;
          spherical.phi += sphericalDelta.phi;

          // restrict theta to be between desired limits
          spherical.theta = Math.max(
            minAzimuthAngle,
            Math.min(maxAzimuthAngle, spherical.theta)
          );

          // restrict phi to be between desired limits
          spherical.phi = Math.max(
            minPolarAngle,
            Math.min(maxPolarAngle, spherical.phi)
          );

          spherical.makeSafe();

          spherical.radius *= scale;

          // restrict radius to be between desired limits
          spherical.radius = Math.max(
            minDistance,
            Math.min(maxDistance, spherical.radius)
          );

          // move target to panned location
          // target.add( panOffset );

          offset.setFromSpherical(spherical);

          // rotate offset back to "camera-up-vector-is-up" space
          offset.applyQuaternion(quatInverse);

          position.copy(target).add(offset);

          object.lookAt(target);

          if (enableDamping === true) {
            sphericalDelta.theta *= 1 - dampingFactor;
            sphericalDelta.phi *= 1 - dampingFactor;

            // panOffset.multiplyScalar( 1 - dampingFactor );
          } else {
            sphericalDelta.set(0, 0, 0);

            // panOffset.set( 0, 0, 0 );
          }

          // scale = 1;

          // update condition is:
          // min(camera displacement, camera rotation in radians)^2 > EPS
          // using small-angle approximation cos(x/2) = 1 - x^2 / 8

          // if ( zoomChanged ||
          //     lastPosition.distanceToSquared( scope.object.position ) > EPS ||
          //     8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ) {

          //     scope.dispatchEvent( changeEvent );

          //     lastPosition.copy( scope.object.position );
          //     lastQuaternion.copy( scope.object.quaternion );
          //     zoomChanged = false;

          //     return true;

          // }

          return false;
        };
      }
      // new SelectHandler(canvas)
      //   .onStart(e => {
      //     rotateStart.set(e.e.clientX, e.e.clientY);
      //   })
      //   .onSelect(e => {
      //     const event = e.e;
      //     rotateEnd.set(event.clientX, event.clientY);
      //     rotateDelta
      //       .subVectors(rotateEnd, rotateStart)
      //       .multiplyScalar(rotateSpeed);

      //     var element = canvas;

      //     rotateLeft((2 * Math.PI * rotateDelta.x) / element.clientHeight); // yes, height

      //     rotateUp((2 * Math.PI * rotateDelta.y) / element.clientHeight);

      //     rotateStart.copy(rotateEnd);

      //     // console.log(e);
      //     update()();
      //   })
      //   .onEnd(e => {})
      //   .startSelect();
    </script>
  </body>
</html>
