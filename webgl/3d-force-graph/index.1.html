<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta http-equiv="X-UA-Compatible" content="ie=edge" />
  <title>3d-force-graph</title>
  <script src="../../lib/threejs/three.js"></script>
  <script src="../../lib/d3/d3.js"></script>
  <script src="./3d-force-graph-1.45.6/dist/3d-force-graph.js"></script>
  <script src="./SelectHandler.js"></script>
  <style>
    body {
      margin: 0;
    }
  </style>
</head>

<body>
  <div id="3d-graph"></div>

  <script>
    // Random tree
    const N = 100;
    const gData = {
      nodes: [...Array(N).keys()].map(i => ({
        id: i
      })),
      links: [...Array(N).keys()]
        .filter(id => id)
        .map(id => ({
          source: id,
          target: Math.round(Math.random() * (id - 1))
        }))
    };

    const Graph = ForceGraph3D({
        controlType: "trackball"
      })(document.getElementById("3d-graph"))
      .graphData(gData)
      .forceEngine("d3")
      //  .forceEngine('ngraph')
      .enableNodeDrag(true)
      //  .cooldownTicks(0)
      .cooldownTime(500)
      .numDimensions(3)
      .nodeRelSize(10)
      .linkColor(0xff0000)
      .linkWidth(1)
      .linkOpacity(0.4)
      // .linkMaterial(function() {
      //     return new THREE.LineBasicMaterial({
      //         color: 0xFF0000,
      //         linewidth: 1
      //     });
      // })
      .linkThreeObject(function (link) {
        const geometry = new THREE.BufferGeometry();
        const material = new THREE.LineBasicMaterial({
          color: 0x1f3d7a,
          linewidth: 1,
          linecap: "round"
        });
        material.transparent = true;
        material.opacity = 0.5;
        const positions = [];
        positions.push(link.source.x, link.source.y, link.source.z);
        positions.push(link.target.x, link.target.y, link.target.z);
        geometry.addAttribute(
          "position",
          new THREE.Float32BufferAttribute(positions, 3)
        );
        return new THREE.Line(geometry, material);
      })
      .nodeOpacity(1)
      .d3Force("collision", d3.forceCollide(20));
    //  .linkDirectionalArrowLength(15)
    //  .linkDirectionalArrowRelPos(1)
    //  .linkCurvature(1)
    var scene = Graph.scene();
    var orbitControl = Graph.controls();
    var camera = Graph.camera();
    var renderer = Graph.renderer();
    var canvas = renderer.domElement;
    var domElement = canvas;
    var theta = 0;
    var radius = 100;

    var object = camera;
    var target = new THREE.Vector3();
    var _movePrev = new THREE.Vector2();
    var _moveCurr = new THREE.Vector2();
    var _eye = new THREE.Vector3();
    var _lastAxis = new THREE.Vector3();
    var _lastAngle = 0;
    var rotateSpeed = 1.0;
    var staticMoving = false;
    var dynamicDampingFactor = 0.2;
    var lastPosition = new THREE.Vector3();
    var EPS = 0.000001;
    var noRotate = false;
    var noZoom = false;
    var noPan = false;
    var minDistance = 0;
    var maxDistance = Infinity;
    var _zoomStart = new THREE.Vector2();
    var _zoomEnd = new THREE.Vector2();
    var screen = {
      left: 0,
      top: 0,
      width: 0,
      height: 0
    };
    var handleResize = function () {

      if (domElement === document) {

        screen.left = 0;
        screen.top = 0;
        screen.width = window.innerWidth;
        screen.height = window.innerHeight;

      } else {

        var box = domElement.getBoundingClientRect();
        // adjustments come from similar code in the jquery offset() function
        var d = domElement.ownerDocument.documentElement;
        screen.left = box.left + window.pageXOffset - d.clientLeft;
        screen.top = box.top + window.pageYOffset - d.clientTop;
        screen.width = box.width;
        screen.height = box.height;

      }

    };
    var getMouseOnCircle = (function () {

      var vector = new THREE.Vector2();

      return function getMouseOnCircle(pageX, pageY) {

        vector.set(
          ((pageX - screen.width * 0.5 - screen.left) / (screen.width * 0.5)),
          ((screen.height + 2 * (screen.top - pageY)) / screen
            .width) // screen.width intentional
        );

        return vector;

      };

    }());
    var rotateCamera = (function () {

      var axis = new THREE.Vector3(),
        quaternion = new THREE.Quaternion(),
        eyeDirection = new THREE.Vector3(),
        objectUpDirection = new THREE.Vector3(),
        objectSidewaysDirection = new THREE.Vector3(),
        moveDirection = new THREE.Vector3(),
        angle;

      return function rotateCamera() {

        moveDirection.set(_moveCurr.x - _movePrev.x, _moveCurr.y - _movePrev.y, 0);
        angle = moveDirection.length();

        if (angle) {

          _eye.copy(object.position).sub(target);

          eyeDirection.copy(_eye).normalize();
          objectUpDirection.copy(object.up).normalize();
          objectSidewaysDirection.crossVectors(objectUpDirection, eyeDirection).normalize();

          objectUpDirection.setLength(_moveCurr.y - _movePrev.y);
          objectSidewaysDirection.setLength(_moveCurr.x - _movePrev.x);

          moveDirection.copy(objectUpDirection.add(objectSidewaysDirection));

          axis.crossVectors(moveDirection, _eye).normalize();

          angle *= rotateSpeed;
          quaternion.setFromAxisAngle(axis, angle);

          _eye.applyQuaternion(quaternion);
          object.up.applyQuaternion(quaternion);

          _lastAxis.copy(axis);
          _lastAngle = angle;

        } else if (!staticMoving && _lastAngle) {

          _lastAngle *= Math.sqrt(1.0 - dynamicDampingFactor);
          _eye.copy(object.position).sub(target);
          quaternion.setFromAxisAngle(_lastAxis, _lastAngle);
          _eye.applyQuaternion(quaternion);
          object.up.applyQuaternion(quaternion);

        }

        _movePrev.copy(_moveCurr);

      };
    }());
    var checkDistances = function () {

      if (!noZoom || !noPan) {

        if (_eye.lengthSq() > maxDistance * maxDistance) {

          object.position.addVectors(target, _eye.setLength(maxDistance));
          _zoomStart.copy(_zoomEnd);

        }

        if (_eye.lengthSq() < minDistance * minDistance) {

          object.position.addVectors(target, _eye.setLength(minDistance));
          _zoomStart.copy(_zoomEnd);

        }

      }

    };
    var update = function () {
      _eye.subVectors(object.position, target);
      rotateCamera();

      object.position.addVectors(target, _eye);
      checkDistances();
      object.lookAt(target);
      if (lastPosition.distanceToSquared(object.position) > EPS) {
        // dispatchEvent( changeEvent );
        lastPosition.copy(object.position);
      }
    };
    new SelectHandler(canvas)
      .onStart(e => {
        const event = e.e;
        _moveCurr.copy(getMouseOnCircle(event.pageX, event.pageY));
        _movePrev.copy(_moveCurr);
      })
      .onSelect(e => {
        const event = e.e;
        _movePrev.copy(_moveCurr);
        _moveCurr.copy(getMouseOnCircle(event.pageX, event.pageY));
        update();
      })
      .onEnd(e => {})
      .startSelect();

    handleResize();
    update();
  </script>
</body>

</html>