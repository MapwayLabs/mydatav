<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <script src="../../lib/zrender/zrender.js"></script>
  <script src="../../lib/d3.v4.min.js"></script>
  <title>z_nodelinks</title>
</head>
<body>
  <div id="main" style="width:400px;height:300px;background:#999;"></div>

  <script>
      function le(e, t, i, o, n, S, O, path) {
        var w = .75;
        var a = o - t
          , r = i - e
          , s = Math.sqrt(a * a + r * r)
          , d = w;
        if (0 < r * n ? s < S && (d = .75 - (S - s) / S * .75) : d = .4 - .2 * Math.max(0, (S - Math.min(Math.abs(r), Math.abs(a))) / S),
        0 < r * n)
            // return "M " + e + " " + t + " C " + (e + n * (S * d)) + " " + (t + 0 * O) + " " + (i - n * d * S) + " " + (o - 0 * O) + " " + i + " " + o;
            return ( path.moveTo(e, t), path.bezierCurveTo((e + n * (S * d)), (t + 0 * O), (i - n * d * S), (o - 0 * O),i, o) );
        var l = Math.floor(i - r / 2)
          , c = Math.floor(o - a / 2);
        0 == a && (c = o + O);
        var p = O / 2
          , u = (o + c) / 2
          , f = e + n * S * d
          , h = 0 < a ? Math.min(u - a / 2, t + p) : Math.max(u - a / 2, t - p)
          , g = i - n * S * d
          , v = 0 < a ? Math.max(u, o - p) : Math.min(u, o + p)
          , b = (e + f) / 2
          , m = 0 < a ? 1 : -1
          , y = [[b, t], [f, 0 < a ? Math.max(t, h - p) : Math.min(t, h + p)], [b, 0 < a ? Math.min(c, h + p) : Math.max(c, h - p)], [g, 0 < a ? Math.max(c, v - p) : Math.min(c, v + p)], [(i + g) / 2, o]];
        return y[2][1] === h + m * p && (Math.abs(a) < 10 * p && (y[1][1] = h - m * p / 2,
        y[3][1] = v - m * p / 2),
        y[2][0] = f),
            path.moveTo(e, t),
            path.bezierCurveTo(
              y[0][0], y[0][1],
              y[1][0], y[1][1],
              f, h
            ),
            path.bezierCurveTo(
              f * 2 - y[1][0], h * 2 - y[1][1],
              y[2][0], y[2][1],
              l, c
            ),
            path.bezierCurveTo(
              l * 2 - y[2][0], c * 2 - y[2][1],
              y[3][0], y[3][1],
              g, v
            ),
            path.bezierCurveTo(
              g * 2 - y[3][0], v * 2 - y[3][1],
              y[4][0], y[4][1],
              i, o
            );
        // "M " + e + " " + t + " C " + y[0][0] + " " + y[0][1] + " " + y[1][0] + " " + y[1][1] + " " + f + " " + h + " S " + y[2][0] + " " + y[2][1] + " " + l + " " + c + " S " + y[3][0] + " " + y[3][1] + " " + g + " " + v + " S " + y[4][0] + " " + y[4][1] + " " + i + " " + o
    }
    function le222(e, t, i, o, n, S, O, path) {
      var w = .75;
      var a = o - t
        , r = i - e
        , s = Math.sqrt(a * a + r * r)
        , d = w;
      if (0 < r * n ? s < S && (d = .75 - (S - s) / S * .75) : d = .4 - .2 * Math.max(0, (S - Math.min(Math.abs(r),   Math.abs(a))) / S),
      0 < r * n) {
        // path.moveTo(e, t);
        // path.bezierCurveTo(
        //   (e + n * (S * d)), (t + 0 * O),
        //   (i - n * d * S), (o - 0 * O),
        //   i, o
        // );
        // return;
      }

      if (0 < r * n) {
        // path.moveTo(e, t);
        // path.bezierCurveTo(
        //   (e + n * (S * d)), (t + 0 * O),
        //   (i - n * d * S), (o - 0 * O),
        //   i, o
        // );
        // return;
               return "M " + e + " " + t + " C " + (e + n * (S * d)) + " " + (t + 0 * O) + " " + (i - n * d * S) + " " +   (o - 0 * O) + " " + i + " " + o;
      }
          // return "M " + e + " " + t + " C " + (e + n * (S * d)) + " " + (t + 0 * O) + " " + (i - n * d * S) + " " +   (o - 0 * O) + " " + i + " " + o;
      var l = Math.floor(i - r / 2)
        , c = Math.floor(o - a / 2);
      0 == a && (c = o + O);
      var p = O / 2
        , u = (o + c) / 2
        , f = e + n * S * d
        , h = 0 < a ? Math.min(u - a / 2, t + p) : Math.max(u - a / 2, t - p)
        , g = i - n * S * d
        , v = 0 < a ? Math.max(u, o - p) : Math.min(u, o + p)
        , b = (e + f) / 2
        , m = 0 < a ? 1 : -1
        , y = [[b, t], [f, 0 < a ? Math.max(t, h - p) : Math.min(t, h + p)], [b, 0 < a ? Math.min(c, h + p) : Math.max  (c, h - p)], [g, 0 < a ? Math.max(c, v - p) : Math.min(c, v + p)], [(i + g) / 2, o]];
        if (y[2][1] === h + m * p && (Math.abs(a) < 10 * p && (y[1][1] = h - m * p / 2,
          y[3][1] = v - m * p / 2),
          y[2][0] = f)) {
            path.moveTo(e, t);
            path.bezierCurveTo(
              y[0][0], y[0][1],
              y[1][0], y[1][1],
              f, h
            );
            path.bezierCurveTo(
              f * 2 - y[1][0], h * 2 - y[1][1],
              y[2][0], y[2][1],
              l, c
            );
            path.bezierCurveTo(
              l * 2 - y[2][0], c * 2 - y[2][1],
              y[3][0], y[3][1],
              g, v
            );
            path.bezierCurveTo(
              g * 2 - y[3][0], v * 2 - y[3][1],
              y[4][0], y[4][1],
              i, o
            );
            return;
          }
      // return y[2][1] === h + m * p && (Math.abs(a) < 10 * p && (y[1][1] = h - m * p / 2,
      // y[3][1] = v - m * p / 2),
      // y[2][0] = f),
      // "M " + e + " " + t + " C " + y[0][0] + " " + y[0][1] + " " + y[1][0] + " " + y[1][1] + " " + f + " " + h + "   S " + y[2][0] + " " + y[2][1] + " " + l + " " + c + " S " + y[3][0] + " " + y[3][1] + " " + g + " " + v + " S "   + y[4][0] + " " + y[4][1] + " " + i + " " + o
    }
    var CurveLink = zrender.Path.extend({
       type: 'CurveLink',
       shape: {
          x1: 0,
          y1: 0,
          x2: 0,
          y2: 0,
          dir: 1,
          width: 0,
          height: 0
       },
       buildPath: function (path, shape) {
        //  le(shape.x1, shape.y1, shape.x2, shape.y2, 1, shape.width, shape.height, path);
         le(shape.x1 + shape.width / 2, shape.y1, shape.x2 - shape.width / 2, shape.y2, shape.dir, shape.width, shape.height, path);
         return;
         var origX = shape.x1 + shape.width / 2;
         var origY = shape.y1;
         var destX = shape.x2 - shape.width / 2;
         var destY = shape.y2;
         var dx = destX - origX;
         var dy = destY - origY;
         var dir = shape.dir;
         var node_width = shape.width;
         var node_height = shape.height;
         var delta = Math.sqrt(dy * dy + dx * dx);
         var scale = 1;
         var scaleY = 0;
         if (dx * dir > 0) {
           if (delta < node_width) {
             scale = 0.75-0.75*((node_width-delta)/node_width);
             // scale += 2*(Math.min(5*node_width,Math.abs(dx))/(5*node_width));
             // if (Math.abs(dy) < 3*node_height) {
             //     scaleY = ((dy>0)?0.5:-0.5)*(((3*node_height)-Math.abs(dy))/(3*node_height))*(Math.min   (node_width,Math.abs(dx))/(node_width)) ;
             // }
           }
         } else {
           scale = 0.4-0.2*(Math.max(0,(node_width-Math.min(Math.abs(dx),Math.abs(dy)))/node_width));
         }
         if (dx * dir > 0) {
           path.moveTo(origX, origY);
           path.bezierCurveTo(
             (origX + dir * (node_width * scale)), (origY + scaleY * node_height),
             (destX - dir * (node_width * scale)), (destY - scaleY * node_height),
             destX, destY
           );
         } else {
   
           var midX = Math.floor(destX - dx / 2);
           var midY = Math.floor(destY - dy / 2);
           //
           if (dy === 0) {
             midY = destY + node_height;
           }
           var cp_height = node_height / 2;
           var y1 = (destY + midY) / 2
           var topX = origX + dir * node_width * scale;
           var topY = dy > 0 ? Math.min(y1 - dy/2 , origY + cp_height) : Math.max(y1 - dy/2 , origY - cp_height);
           var bottomX = destX - dir * node_width * scale;
           var bottomY = dy > 0 ? Math.max(y1, destY - cp_height) : Math.min(y1, destY + cp_height);
           var x1 = (origX + topX) / 2;
           var scy = dy > 0 ? 1 : -1;
           var cp = [
             // Orig -> Top
             [x1, origY],
             [topX, dy > 0 ? Math.max(origY, topY - cp_height) : Math.min(origY, topY + cp_height)],
             // Top -> Mid
             // [Mirror previous cp]
             [x1,dy > 0 ? Math.min(midY, topY + cp_height) : Math.max(midY, topY - cp_height)],
             // Mid -> Bottom
             // [Mirror previous cp]
             [bottomX,dy > 0 ? Math.max(midY, bottomY - cp_height) : Math.min(midY, bottomY + cp_height)],
             // Bottom -> Dest
             // [Mirror previous cp]
             [(destX + bottomX) / 2, destY]
           ];
           if (cp[2][1] === topY + scy * cp_height) {
             if (Math.abs(dy) < cp_height * 10) {
               cp[1][1] = topY - scy * cp_height / 2;
               cp[3][1] = bottomY - scy * cp_height / 2;
             }
             cp[2][0] = topX;
           }

           path.moveTo(origX, origY);
           path.bezierCurveTo(
             cp[0][0], cp[0][1],
             cp[1][0], cp[1][1],
             topX, topY
           );
           path.bezierCurveTo(
             topX * 2 - cp[1][0], topY * 2 - cp[1][1],
             cp[2][0], cp[2][1],
             midX, midY
           );
           path.bezierCurveTo(
             midX * 2 - cp[2][0], midY * 2 - cp[2][1],
             cp[3][0], cp[3][1],
             bottomX, bottomY
           );
           path.bezierCurveTo(
             bottomX * 2 - cp[3][0], bottomY * 2 - cp[3][1],
             cp[4][0], cp[4][1],
             destX, destY
           );
         }
       }
    });
  </script>

  <script>
    var zr = zrender.init(document.getElementById('main'), {
      renderer: 'canvas'
    });
    var g = new zrender.Group({
      draggable: true
    });

    var radius = 15;
    
    var point1 = { x: 150, y: 50 };
    var circle1 = new zrender.Circle({
      draggable: true,
      silent: false,
      shape: {
          cx: point1.x,
          cy: point1.y,
          r: radius
      },
      style: {
          fill: '#f00'
      }
    });
    circle1.afterUpdate = function() {
      point1.x = circle1.shape.cx + circle1.position[0];
      point1.y = circle1.shape.cy + circle1.position[1];
      bezier.attr({ shape: {
        x1: point1.x,
        y1: point1.y,
        x2: point2.x,
        y2: point2.y,
      }});
    }
    g.add(circle1);
    
    var point2 = { x: 250, y: 100 };
    var circle2 = new zrender.Circle({
      draggable: true,
      shape: {
          cx: point2.x,
          cy: point2.y,
          r: radius
      },
      style: {
          fill: '#0f0'
      }
    });
    circle2.afterUpdate = function() {
      point2.x = circle2.shape.cx + circle2.position[0];
      point2.y = circle2.shape.cy + circle2.position[1];
      bezier.attr({ shape: {
        x1: point1.x,
        y1: point1.y,
        x2: point2.x,
        y2: point2.y,
      }});
    }
    g.add(circle2);


    function curveHorizontal(x0, y0, x1, y1) {
      return {
        x1: x0,
        y1: y0,
        x2: x1,
        y2: y1,
        cpx1: (x0 + x1) / 2,
        cpy1: y0,
        cpx2: x0,
        cpy2: y1
      };
    }

    function curveVertical(x0, y0, x1, y1) {
      return {
        x1: x0,
        y1: y0,
        x2: x1,
        y2: y1,
        cpx1: x0,
        cpy1: (y0 + y1) / 2,
        cpx2: x1,
        cpy2: y0
      };
    }

    function curveRadial(x0, y0, x1, y1) {
      var p0 = pointRadial(x0, y0),
          p1 = pointRadial(x0, y0 = (y0 + y1) / 2),
          p2 = pointRadial(x1, y0),
          p3 = pointRadial(x1, y1);
      return {
        x1: x0,
        y1: y0,
        x2: x1,
        y2: y1,
        cpx1: p1[0],
        cpy1: p1[1],
        cpx2: p2[0],
        cpy2: p2[1]
      };
    }

    function pointRadial(x, y) {
      return [(y = +y) * Math.cos(x -= Math.PI / 2), y * Math.sin(x)];
    }

    // var bezier = new zrender.BezierCurve({
    //   shape: curveHorizontal(point1.x, point1.y, point2.x, point2.y),
    //   style: {
    //     stroke: '#000'
    //   }
    // });
    // g.add(bezier);

    var bezier = new CurveLink({
      shape: {
        x1: point1.x,
        y1: point1.y,
        x2: point2.x,
        y2: point2.y,
        dir: 1,
        width: radius * 2,
        height: radius * 2
      },
      style: {
        stroke: '#000',
        fill: null
      }
    });
    g.add(bezier);

    zr.add(g);


    var count = 0;
    zr.on('mousemove', e => {
      // console.log('mousemove:' + count++,e);
      zr.clearHover();
      if (e.target) {
        zr.addHover(e.target, {
          stroke: '#f00'
        });
      } else {
        zr.setCursorStyle("move");
      }
    });

    var drag = d3.drag()
    .on("start", function(e) {
      const result = zr.findHover(d3.event.x, d3.event.y);
      if (result.target) {
        return false;
      } else {

      }
      // console.log('start', d3.event, '\n');
    })
    .on("drag", function(e) {
      // console.log('drag', d3.event, '\n');
    })
    .on("end", function(e) {
      // console.log('end', d3.event, '\n');
    });
    // d3.select("#main").call(drag);

    var zoom = d3.zoom()
    .on("start", function(e) {
      console.log('start', d3.event, '\n');
    })
    .on("zoom", function(e) {
      console.log('zoom', d3.event, '\n');
    })
    .on("end", function(e) {
      console.log('end', d3.event, '\n');
    });
    // d3.select("#main").call(zoom);
  </script>
</body>
</html>